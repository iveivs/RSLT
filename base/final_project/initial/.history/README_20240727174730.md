В данном задании мы вспомним ООП и поработаем с кодом, близким к тому, как используются фреймворки для разработки приложений. Прежде всего давайте определим, что такое фреймворк.

Фреймворк — это набор готовых инструментов, библиотек и правил, который упрощает создание приложений. 

Иными словами, используя какой-либо фреймворк мы обязуемся следовать его правилам по организации кода. Благодаря этому другой разработчик, зная эти же правила, сможет без проблем разобраться в нашем коде и продолжить разработку приложения. 

Вам дан стартовый проект: .

Работая с этим проектом мы будем имитировать работу с фреймворком. 

В проект добавлено небольшое демонстрационное приложение. Но прежде чем изучать его работу, давайте разберемся со структурой проекта. 

1. Для сборки модулей в проект добавлена Webpack-конфигурация. Для запуска необходимо установить зависимости командой npm i и запустить приложение командой `npm start`.
2. В папке `/src` находится весь исходный код приложения.
3. Файл `/src/index.js` — точка входа в приложение. Здесь мы подключаем корневой главный компонент и выводим его на страницу (далее мы поймем, как использовать компоненты).
4. Файл `/src/index.html` остается с пустым тегом <body>. В данном приложении вся разметка будет генерироваться с помощью JavaScript.
5. В папке `/src/core` содержится весь исходный код нашего мини-фреймворка. На данный момент это один класс Component.
6. В папке `/src/components` находятся все компоненты, используемые приложением. В данном случае компонент — это класс, который отвечает за отображение одной какой-либо части приложения на экран и содержит логику, связанную с этой частью.

На компонентах мы остановимся подробнее. Используя наш фреймворк, мы должны соблюдать некоторые правила работы с ним. Ниже приведена инструкция по работе с компонентами.

## Создание компонента

Все файлы компонентов должны находиться в папке `/src/components/.` Компоненты должны быть представлены в виде классов и наследоваться от базового класса **Component   **, который находится в папке `/src/core`.
``` javascript
// /src/components/YourComponent.js
import { Component } from '../core/Component';

export class YourComponent extends Component {
  // ...
}
```

## Метод setup()

В компоненте обязательно должен быть метод setup(), внутри которого необходимо создать корневой элемент компонента и записать его в поле $rootElement. И уже внутри этого элемента формируем необходимую разметку. 


``` javascript
// Файл /src/components/YourComponent.js
 import { Component } from '../core/Component';

export class YourComponent extends Component {
  setup() {
    // Создаем корневой элемент
    this.$rootElement = document.createElement('div');
    
    // Устанавливаем ему класс, чтобы можно было стилизовать
    this.$rootElement.className = 'component';

    // Создаем дочерний элемент
    const $heading = document.createElement('h1');
    $heading.textContent = 'Hello world';
    
    // Добавляем заголовок в корневой элемент
    this.$rootElement.appendChild($heading);
  }
}
```
Обратите внимание, `$` в начале названий обозначает, что внутри переменной или поля содержится именно DOM-узел. Это сделано для наглядности и удобства. 

## Вывод компонента

Чтобы добавить компонент на страницу, можно использовать стандартные методы DOM API. Создаем экземпляр класса компонента и вставляем элемент, который находится в `$rootElement.`
```javascript
// Файл /src/index.js
import { YourComponent } from './components/YourComponent';

document.addEventListener('DOMContentLoaded', function () {    
  const yourComponent = new YourComponent();
  document.body.appendChild(yourComponent.$rootElement);
});
```

## Входные параметры

При инициализации компонента можно передать объект, в котором будут содержатся входные параметры. Например, мы хотим, чтобы заголовок внутри компонента вывел Hello world. 

```javascript

// Файл /src/index.js
import { YourComponent } from './components/YourComponent';

document.addEventListener('DOMContentLoaded', function () {
  // Передаем объект, в котором определим свойство heading
  const yourComponent = new YourComponent({ heading: 'Hello world' });
  document.body.appendChild(yourComponent.$rootElement);
});
```

Этот объект будет доступен в методе `setup()` первым параметром — `props`.

```javascript 
// Файл /src/components/YourComponent.js
import { Component } from '../core/Component';

export class YourComponent extends Component {
  setup(props) {
    this.$rootElement = document.createElement('div');
    const $heading = document.createElement('h1');
    $heading.textContent = props.heading; // В заголовке будет "Hello world"
    this.$rootElement.appendChild($heading);
  }
}
```
В данный момент нас не сильно интересует, как именно так получилось, что при передаче аргумента в конструктор он попал в метод setup(). Об этом позаботился фреймворк (а именно, родительский класс Component). Мы только знаем о такой возможности из правил работы с фреймворком, а как именно это реализовано, мы можем не знать.

Конечно, в нашем случае вы можете открыть файл /src/core/Component.js и понять, почему так происходит. Это упрощенный пример, но при работе с настоящим фреймворком разобраться в его внутренних механизмах будет уже не так просто. Поэтому команда разработки фреймворка определяет все его возможности и особенности в документации, а разработчики, использующие фреймворк, обращаются к ней, чтобы узнать, как именно нужно его использовать. 




